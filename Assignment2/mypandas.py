from collections import OrderedDictimport csvfrom dateutil.parser import parseimport datetime,timeclass DataFrame(object):    @classmethod    def from_csv(cls, file_path, delimiting_character=',', quote_character='"'):        with open(file_path, 'rU') as infile:            reader = csv.reader(infile, delimiter=delimiting_character, quotechar=quote_character)            data = []            for row in reader:                data.append(row)            return cls(list_of_lists=data)    def __init__(self, list_of_lists, header=True):        if header:            self.header = list_of_lists[0]            self.data = list_of_lists[1:]        else:            self.header = ['column' + str(index + 1) for index, column in enumerate(list_of_lists[0])]            self.data = list_of_lists        ############# task 1 #############        if len(self.header) != len(set(self.header)):            raise Exception('There are duplicates!!!')        ############# end task 1 #############        ############# task 2 #############        self.data=[[s.strip() for s in row] for row in self.data]        ############# end task 2 #############        self.data = [OrderedDict(zip(self.header, row)) for row in self.data]    def __getitem__(self, item):        # this is for rows only        if isinstance(item, (int, slice)):            return self.data[item]        # this is for columns only        elif isinstance(item, str):            return [row[item] for row in self.data]        # this is for rows and columns        elif isinstance(item, tuple):            if isinstance(item[0], list) or isinstance(item[1], list):                if isinstance(item[0], list):                    rowz = [row for index, row in enumerate(self.data) if index in item[0]]                else:                    rowz = self.data[item[0]]                if isinstance(item[1], list):                    if all([isinstance(thing, int) for thing in item[1]]):                        return [[column_value for index, column_value in enumerate([value for value in row.itervalues()]) if index in item[1]] for row in rowz]                    elif all([isinstance(thing,str) for thing in item[1]]):                        return [[row[column_name] for column_name in item[1]] for row in rowz]                    else:                        raise TypeError('What the hell is this?')                else:                    return [[value for value in row.itervalues()][item[1]] for row in rowz]            else:                if isinstance(item[1], (int, slice)):                    return [[value for value in row.itervalues()][item[1]] for row in self.data[item[0]]]                elif isinstance(item[1],str):                    return [row[item[1]] for row in self.data[item[0]]]                else:                    raise TypeError('I don\'t know how to handle this...')        # only for lists of column names        elif isinstance(item, list):            return [[row[column_name] for column_name in item] for row in self.data]    def get_rows_where_column_has_value(self, column_name, value, index_only=False):        if index_only:            return [index for index, row_value in enumerate(self[column_name]) if row_value==value]        else:            return [row for row in self.data if row[column_name]==value]    ############# task 3 #############        def type(self,col_name):        is_time = 0        try:            nums = [float(row[col_name].replace(',','')) for row in self.data]            return nums, 1 if is_time else 0        except:            try:                nums = [parse(row[col_name].replace(',','')) for row in self.data]                nums= [time.mktime(num.timetuple()) for num in nums]                is_time = 1                return nums, 1 if is_time else 0            except:                raise TypeError('Cannot be calculated')    def min(self,col_name):        nums, is_time= self.type(col_name)        result = min(nums)        return datetime.datetime.fromtimestamp(result) if is_time else result    def max(self,col_name):        nums, is_time = self.type(col_name)        result = max(nums)        return datetime.datetime.fromtimestamp(result) if is_time else result    def median(self,col_name):        nums, is_time = self.type(col_name)        nums = sorted(nums)        center = int(len(nums) / 2)        if len(nums) % 2 == 0:            result = sum(nums[center - 1:center + 1]) / 2.0            return datetime.datetime.fromtimestamp(result) if is_time else result        else:            result = nums[center]            return datetime.datetime.fromtimestamp(result) if is_time else result    def mean(self,col_name):        nums, is_time = self.type(col_name)        result = sum(nums)/len(nums)        return datetime.datetime.fromtimestamp(result) if is_time else result    def sum(self,col_name):        nums,is_time = self.type(col_name)        return sum(nums)    def std(self,col_name):        nums ,is_time = self.type(col_name)        mean = sum(nums)/len(nums)        return (sum([(num-mean)**2 for num in nums])/len(nums))**0.5    ############# end task 3 #############    ############# task 4 #############        def add_rows(self, list_of_lists):        for new_list in list_of_lists:            if len(new_list) == len(self.header):                new_row = [OrderedDict(zip(self.header, row)) for row in list_of_lists]                self.data = self.data + new_row                return self            else:                raise Exception('Wrong number of columns')    ############# end task 4 #############    ############# task 5 #############        def add_column(self, list_of_values, column_name):        if len(list_of_values) == len(self.data):            self.header.append(column_name)            for index, row in enumerate(self.data):                row.update({column_name: list_of_values[index]})            return self        else:            raise Exception("Wrong number of rows")    ############# end task 5 #############'''infile = open('SalesJan2009.csv')lines = infile.readlines()lines = lines[0].split('\r')data = [l.split(',') for l in lines]things = lines[559].split('"')data[559] = things[0].split(',')[:-1] + [things[1]] + things[-1].split(',')[1:]df = DataFrame.from_csv('SalesJan2009.csv')# get the 5th rowfifth = df[4]sliced = df[4:10]# get item definition for df [row, column]# get the third columntupled = df[:, 2]tupled_slices = df[0:5, :3]tupled_bits = df[[1, 4], [1, 4]]# adding header for data with no headerdf = DataFrame(list_of_lists=data[1:], header=False)# fetch columns by namenamed = df['column1']named_multi = df[['column1', 'column7']]#fetch rows and (columns by name)named_rows_and_columns = df[:5, 'column7']named_rows_and_multi_columns = df[:5, ['column4', 'column7']]#testing from_csv class methoddf = DataFrame.from_csv('SalesJan2009.csv')rows = df.get_rows_where_column_has_value('Payment_Type', 'Visa')indices = df.get_rows_where_column_has_value('Payment_Type', 'Visa', index_only=True)rows_way2 = df[indices, ['Product', 'City']]''''''# ============test task 3============test = df.min('Price')test1 = df.max('Last_Login')test2 = df.mean('Price')test3 = df.median('Last_Login')test4 = df.sum('Price')test5 = df.std('Last_Login')# ============test task 4============new_row = [['1/2/09 6:17','Product1','1200','Mastercard','carolina',    'Basildon','England','United Kingdom','1/2/09 6:00','1/2/09 6:08','51.5','-1.1166667'],    ['1/2/09 4:53','Product1','1200','Visa','Betina',    'Parkville','M0','United States','1/2/09 4:42','1/2/2009 7:49','39.195','-94.68194']]df = df.add_rows(new_row)			                   						# ============test task 5============testvalues = []for i in range(0, len(df.data)):    testvalues.append('Testvalue' + str(i))df.add_column(testvalues, 'Patricks_Column')'''